{"ast":null,"code":"import { useEffect, useState } from 'react';\nconst IS_BROWSER = false;\n/**\r\n * Watch for the scrolling intersection of a React component or\r\n * Element.\r\n *\r\n * @param hookProperties - Configuration object for this hook.\r\n *\r\n * @returns A boolean representing if the observed component\r\n * or Element is in view.\r\n */\n\nexport const useIntersectionObserver = ({\n  ref,\n  element,\n  options = {\n    triggerOnce: true,\n    threshold: 0\n  },\n  callback\n}) => {\n  const {\n    0: inView,\n    1: setInView\n  } = useState(false);\n\n  const handleIntersect = entries => {\n    if (!intersectObs) return; // In the case that we only want to trigger once, we can consider\n    // that if any entry has intersected, we've scrolled past the observed\n    // element.\n\n    if (options.triggerOnce) {\n      const hasIntersected = entries.some(e => e.isIntersecting);\n\n      if (hasIntersected) {\n        callback === null || callback === void 0 ? void 0 : callback(entries);\n        intersectObs.disconnect();\n      }\n\n      setInView(hasIntersected);\n      return;\n    } // Otherwise, in situations where scrolling is **really** fast or the browser\n    // is busy, we can consider that the last entry is the most up-to-date.\n\n\n    const isIntersecting = entries[entries.length - 1].isIntersecting;\n    if (isIntersecting) callback === null || callback === void 0 ? void 0 : callback(entries);\n    setInView(isIntersecting);\n  };\n\n  const {\n    0: intersectObs\n  } = useState(() => IS_BROWSER ? new IntersectionObserver(handleIntersect, options) : undefined);\n  useEffect(() => {\n    if (!intersectObs) return;\n    let domNode;\n    if (ref) domNode = ref.current;else if (element) domNode = element;\n    if (domNode) intersectObs.observe(domNode);\n    return () => intersectObs.disconnect();\n  }, [ref, intersectObs, element]);\n  return inView;\n};","map":{"version":3,"sources":["C:/Users/Ali/Desktop/improver/lib/hooks/use-intersection-observer.tsx"],"names":["useEffect","useState","IS_BROWSER","useIntersectionObserver","ref","element","options","triggerOnce","threshold","callback","inView","setInView","handleIntersect","entries","intersectObs","hasIntersected","some","e","isIntersecting","disconnect","length","IntersectionObserver","undefined","domNode","current","observe"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAA+C,OAA/C;AAyCA,MAAMC,UAAU,QAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAuB,GAAG,CAAC;AACpCC,EAAAA,GADoC;AAEpCC,EAAAA,OAFoC;AAGpCC,EAAAA,OAAO,GAAG;AAAEC,IAAAA,WAAW,EAAE,IAAf;AAAqBC,IAAAA,SAAS,EAAE;AAAhC,GAH0B;AAIpCC,EAAAA;AAJoC,CAAD,KAKE;AACrC,QAAM;AAAA,OAACC,MAAD;AAAA,OAASC;AAAT,MAAsBV,QAAQ,CAAC,KAAD,CAApC;;AAEA,QAAMW,eAAe,GAAIC,OAAD,IAA0C;AAC9D,QAAI,CAACC,YAAL,EAAmB,OAD2C,CAG9D;AACA;AACA;;AACA,QAAIR,OAAO,CAACC,WAAZ,EAAyB;AACrB,YAAMQ,cAAc,GAAGF,OAAO,CAACG,IAAR,CAAcC,CAAD,IAAOA,CAAC,CAACC,cAAtB,CAAvB;;AACA,UAAIH,cAAJ,EAAoB;AAChBN,QAAAA,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAGI,OAAH,CAAR;AACAC,QAAAA,YAAY,CAACK,UAAb;AACH;;AAEDR,MAAAA,SAAS,CAACI,cAAD,CAAT;AACA;AACH,KAf6D,CAiB9D;AACA;;;AACA,UAAMG,cAAc,GAAGL,OAAO,CAACA,OAAO,CAACO,MAAR,GAAiB,CAAlB,CAAP,CAA4BF,cAAnD;AACA,QAAIA,cAAJ,EAAoBT,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAGI,OAAH,CAAR;AAEpBF,IAAAA,SAAS,CAACO,cAAD,CAAT;AACH,GAvBD;;AAyBA,QAAM;AAAA,OAACJ;AAAD,MAAiBb,QAAQ,CAAC,MAC5BC,UAAU,GAAG,IAAImB,oBAAJ,CAAyBT,eAAzB,EAA0CN,OAA1C,CAAH,GAAwDgB,SADvC,CAA/B;AAIAtB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,CAACc,YAAL,EAAmB;AAEnB,QAAIS,OAAJ;AAEA,QAAInB,GAAJ,EAASmB,OAAO,GAAGnB,GAAG,CAACoB,OAAd,CAAT,KACK,IAAInB,OAAJ,EAAakB,OAAO,GAAGlB,OAAV;AAElB,QAAIkB,OAAJ,EAAaT,YAAY,CAACW,OAAb,CAAqBF,OAArB;AAEb,WAAO,MAAMT,YAAY,CAACK,UAAb,EAAb;AACH,GAXQ,EAWN,CAACf,GAAD,EAAMU,YAAN,EAAoBT,OAApB,CAXM,CAAT;AAaA,SAAOK,MAAP;AACH,CAnDM","sourcesContent":["import { useEffect, useState, RefObject } from 'react';\r\n\r\ninterface UseIntersectionObserverProperties {\r\n    ref?: RefObject<Element> | null;\r\n    element?: Element | null | undefined;\r\n    options?: IntersectionObserverOptions;\r\n    callback?: (entries: IntersectionObserverEntry[]) => void;\r\n}\r\n\r\n/**\r\n * Intersection Observer configuratiopn options.\r\n */\r\ninterface IntersectionObserverOptions {\r\n    /**\r\n     * If `true`, check for intersection only once. Will\r\n     * disconnect the IntersectionObserver instance after\r\n     * intersection.\r\n     */\r\n    triggerOnce: boolean;\r\n\r\n    /**\r\n     * Number from 0 to 1 representing the percentage\r\n     * of the element that needs to be visible to be\r\n     * considered as visible. Can also be an array of\r\n     * thresholds.\r\n     */\r\n    threshold: number | number[];\r\n\r\n    /**\r\n     * Element that is used as the viewport for checking visibility\r\n     * of the provided `ref` or `element`.\r\n     */\r\n    root?: Element;\r\n\r\n    /**\r\n     * Margin around the root. Can have values similar to\r\n     * the CSS margin property.\r\n     */\r\n    rootMargin?: string;\r\n}\r\n\r\nconst IS_BROWSER = typeof window !== 'undefined';\r\n\r\n/**\r\n * Watch for the scrolling intersection of a React component or\r\n * Element.\r\n *\r\n * @param hookProperties - Configuration object for this hook.\r\n *\r\n * @returns A boolean representing if the observed component\r\n * or Element is in view.\r\n */\r\nexport const useIntersectionObserver = ({\r\n    ref,\r\n    element,\r\n    options = { triggerOnce: true, threshold: 0 },\r\n    callback,\r\n}: UseIntersectionObserverProperties) => {\r\n    const [inView, setInView] = useState(false);\r\n\r\n    const handleIntersect = (entries: IntersectionObserverEntry[]) => {\r\n        if (!intersectObs) return;\r\n\r\n        // In the case that we only want to trigger once, we can consider\r\n        // that if any entry has intersected, we've scrolled past the observed\r\n        // element.\r\n        if (options.triggerOnce) {\r\n            const hasIntersected = entries.some((e) => e.isIntersecting);\r\n            if (hasIntersected) {\r\n                callback?.(entries);\r\n                intersectObs.disconnect();\r\n            }\r\n\r\n            setInView(hasIntersected);\r\n            return;\r\n        }\r\n\r\n        // Otherwise, in situations where scrolling is **really** fast or the browser\r\n        // is busy, we can consider that the last entry is the most up-to-date.\r\n        const isIntersecting = entries[entries.length - 1].isIntersecting;\r\n        if (isIntersecting) callback?.(entries);\r\n\r\n        setInView(isIntersecting);\r\n    };\r\n\r\n    const [intersectObs] = useState(() =>\r\n        IS_BROWSER ? new IntersectionObserver(handleIntersect, options) : undefined,\r\n    );\r\n\r\n    useEffect(() => {\r\n        if (!intersectObs) return;\r\n\r\n        let domNode;\r\n\r\n        if (ref) domNode = ref.current;\r\n        else if (element) domNode = element;\r\n\r\n        if (domNode) intersectObs.observe(domNode);\r\n\r\n        return () => intersectObs.disconnect();\r\n    }, [ref, intersectObs, element]);\r\n\r\n    return inView;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}