{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nvar IS_BROWSER = true;\n/**\r\n * Watch for the scrolling intersection of a React component or\r\n * Element.\r\n *\r\n * @param hookProperties - Configuration object for this hook.\r\n *\r\n * @returns A boolean representing if the observed component\r\n * or Element is in view.\r\n */\n\nexport var useIntersectionObserver = function useIntersectionObserver(_ref) {\n  _s();\n\n  var ref = _ref.ref,\n      element = _ref.element,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {\n    triggerOnce: true,\n    threshold: 0\n  } : _ref$options,\n      callback = _ref.callback;\n\n  var _useState = useState(false),\n      inView = _useState[0],\n      setInView = _useState[1];\n\n  var handleIntersect = function handleIntersect(entries) {\n    if (!intersectObs) return; // In the case that we only want to trigger once, we can consider\n    // that if any entry has intersected, we've scrolled past the observed\n    // element.\n\n    if (options.triggerOnce) {\n      var hasIntersected = entries.some(function (e) {\n        return e.isIntersecting;\n      });\n\n      if (hasIntersected) {\n        callback === null || callback === void 0 ? void 0 : callback(entries);\n        intersectObs.disconnect();\n      }\n\n      setInView(hasIntersected);\n      return;\n    } // Otherwise, in situations where scrolling is **really** fast or the browser\n    // is busy, we can consider that the last entry is the most up-to-date.\n\n\n    var isIntersecting = entries[entries.length - 1].isIntersecting;\n    if (isIntersecting) callback === null || callback === void 0 ? void 0 : callback(entries);\n    setInView(isIntersecting);\n  };\n\n  var _useState2 = useState(function () {\n    return IS_BROWSER ? new IntersectionObserver(handleIntersect, options) : undefined;\n  }),\n      intersectObs = _useState2[0];\n\n  useEffect(function () {\n    if (!intersectObs) return;\n    var domNode;\n    if (ref) domNode = ref.current;else if (element) domNode = element;\n    if (domNode) intersectObs.observe(domNode);\n    return function () {\n      return intersectObs.disconnect();\n    };\n  }, [ref, intersectObs, element]);\n  return inView;\n};\n\n_s(useIntersectionObserver, \"VQf5K5C8jIbYq/vHdG9HT2E2acI=\");","map":{"version":3,"sources":["C:/Users/Ali/Desktop/improver/lib/hooks/use-intersection-observer.tsx"],"names":["useEffect","useState","IS_BROWSER","useIntersectionObserver","ref","element","options","triggerOnce","threshold","callback","inView","setInView","handleIntersect","entries","intersectObs","hasIntersected","some","e","isIntersecting","disconnect","length","IntersectionObserver","undefined","domNode","current","observe"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAA+C,OAA/C;AAyCA,IAAMC,UAAU,OAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,uBAAuB,GAAG,SAA1BA,uBAA0B,OAKE;AAAA;;AAAA,MAJrCC,GAIqC,QAJrCA,GAIqC;AAAA,MAHrCC,OAGqC,QAHrCA,OAGqC;AAAA,0BAFrCC,OAEqC;AAAA,MAFrCA,OAEqC,6BAF3B;AAAEC,IAAAA,WAAW,EAAE,IAAf;AAAqBC,IAAAA,SAAS,EAAE;AAAhC,GAE2B;AAAA,MADrCC,QACqC,QADrCA,QACqC;;AAAA,kBACTR,QAAQ,CAAC,KAAD,CADC;AAAA,MAC9BS,MAD8B;AAAA,MACtBC,SADsB;;AAGrC,MAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAACC,OAAD,EAA0C;AAC9D,QAAI,CAACC,YAAL,EAAmB,OAD2C,CAG9D;AACA;AACA;;AACA,QAAIR,OAAO,CAACC,WAAZ,EAAyB;AACrB,UAAMQ,cAAc,GAAGF,OAAO,CAACG,IAAR,CAAa,UAACC,CAAD;AAAA,eAAOA,CAAC,CAACC,cAAT;AAAA,OAAb,CAAvB;;AACA,UAAIH,cAAJ,EAAoB;AAChBN,QAAAA,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAGI,OAAH,CAAR;AACAC,QAAAA,YAAY,CAACK,UAAb;AACH;;AAEDR,MAAAA,SAAS,CAACI,cAAD,CAAT;AACA;AACH,KAf6D,CAiB9D;AACA;;;AACA,QAAMG,cAAc,GAAGL,OAAO,CAACA,OAAO,CAACO,MAAR,GAAiB,CAAlB,CAAP,CAA4BF,cAAnD;AACA,QAAIA,cAAJ,EAAoBT,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAGI,OAAH,CAAR;AAEpBF,IAAAA,SAAS,CAACO,cAAD,CAAT;AACH,GAvBD;;AAHqC,mBA4BdjB,QAAQ,CAAC;AAAA,WAC5BC,UAAU,GAAG,IAAImB,oBAAJ,CAAyBT,eAAzB,EAA0CN,OAA1C,CAAH,GAAwDgB,SADtC;AAAA,GAAD,CA5BM;AAAA,MA4B9BR,YA5B8B;;AAgCrCd,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAI,CAACc,YAAL,EAAmB;AAEnB,QAAIS,OAAJ;AAEA,QAAInB,GAAJ,EAASmB,OAAO,GAAGnB,GAAG,CAACoB,OAAd,CAAT,KACK,IAAInB,OAAJ,EAAakB,OAAO,GAAGlB,OAAV;AAElB,QAAIkB,OAAJ,EAAaT,YAAY,CAACW,OAAb,CAAqBF,OAArB;AAEb,WAAO;AAAA,aAAMT,YAAY,CAACK,UAAb,EAAN;AAAA,KAAP;AACH,GAXQ,EAWN,CAACf,GAAD,EAAMU,YAAN,EAAoBT,OAApB,CAXM,CAAT;AAaA,SAAOK,MAAP;AACH,CAnDM;;GAAMP,uB","sourcesContent":["import { useEffect, useState, RefObject } from 'react';\r\n\r\ninterface UseIntersectionObserverProperties {\r\n    ref?: RefObject<Element> | null;\r\n    element?: Element | null | undefined;\r\n    options?: IntersectionObserverOptions;\r\n    callback?: (entries: IntersectionObserverEntry[]) => void;\r\n}\r\n\r\n/**\r\n * Intersection Observer configuratiopn options.\r\n */\r\ninterface IntersectionObserverOptions {\r\n    /**\r\n     * If `true`, check for intersection only once. Will\r\n     * disconnect the IntersectionObserver instance after\r\n     * intersection.\r\n     */\r\n    triggerOnce: boolean;\r\n\r\n    /**\r\n     * Number from 0 to 1 representing the percentage\r\n     * of the element that needs to be visible to be\r\n     * considered as visible. Can also be an array of\r\n     * thresholds.\r\n     */\r\n    threshold: number | number[];\r\n\r\n    /**\r\n     * Element that is used as the viewport for checking visibility\r\n     * of the provided `ref` or `element`.\r\n     */\r\n    root?: Element;\r\n\r\n    /**\r\n     * Margin around the root. Can have values similar to\r\n     * the CSS margin property.\r\n     */\r\n    rootMargin?: string;\r\n}\r\n\r\nconst IS_BROWSER = typeof window !== 'undefined';\r\n\r\n/**\r\n * Watch for the scrolling intersection of a React component or\r\n * Element.\r\n *\r\n * @param hookProperties - Configuration object for this hook.\r\n *\r\n * @returns A boolean representing if the observed component\r\n * or Element is in view.\r\n */\r\nexport const useIntersectionObserver = ({\r\n    ref,\r\n    element,\r\n    options = { triggerOnce: true, threshold: 0 },\r\n    callback,\r\n}: UseIntersectionObserverProperties) => {\r\n    const [inView, setInView] = useState(false);\r\n\r\n    const handleIntersect = (entries: IntersectionObserverEntry[]) => {\r\n        if (!intersectObs) return;\r\n\r\n        // In the case that we only want to trigger once, we can consider\r\n        // that if any entry has intersected, we've scrolled past the observed\r\n        // element.\r\n        if (options.triggerOnce) {\r\n            const hasIntersected = entries.some((e) => e.isIntersecting);\r\n            if (hasIntersected) {\r\n                callback?.(entries);\r\n                intersectObs.disconnect();\r\n            }\r\n\r\n            setInView(hasIntersected);\r\n            return;\r\n        }\r\n\r\n        // Otherwise, in situations where scrolling is **really** fast or the browser\r\n        // is busy, we can consider that the last entry is the most up-to-date.\r\n        const isIntersecting = entries[entries.length - 1].isIntersecting;\r\n        if (isIntersecting) callback?.(entries);\r\n\r\n        setInView(isIntersecting);\r\n    };\r\n\r\n    const [intersectObs] = useState(() =>\r\n        IS_BROWSER ? new IntersectionObserver(handleIntersect, options) : undefined,\r\n    );\r\n\r\n    useEffect(() => {\r\n        if (!intersectObs) return;\r\n\r\n        let domNode;\r\n\r\n        if (ref) domNode = ref.current;\r\n        else if (element) domNode = element;\r\n\r\n        if (domNode) intersectObs.observe(domNode);\r\n\r\n        return () => intersectObs.disconnect();\r\n    }, [ref, intersectObs, element]);\r\n\r\n    return inView;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}